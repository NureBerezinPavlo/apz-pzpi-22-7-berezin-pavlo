Міністерство освіти і науки України
Харківський національний університет радіоелектроніки




Кафедра програмної інженерії




Звіт з практичної роботи № 1
з дисципліни «Архітектура програмного забезпечення»
на тему «Шаблон (патерн) проєктування ПЗ Strategy»




Виконав
студент групи ПЗПІ-22-7
	

Березін Павло Павлович
	

Перевірив
ст. викладач кафедри ПІ
	



Сокорчук Ігор Петрович
	

















Харків, 2024
1.1 Мета роботи


        Метою даної роботи є ознайомлення з одним із найважливіших патернів проєктування програмного забезпечення — Strategy (Стратегія), який належить до поведінкових шаблонів. Дослідження цього патерна дозволяє глибше зрозуміти принципи розділення обов’язків, інкапсуляції алгоритмів та забезпечення гнучкості програмного коду.
Результатом вивчення патерна Strategy є здатність ідентифікувати ситуації, де доцільне його застосування, реалізовувати відповідну архітектуру програмно, а також грамотно оформлювати результати дослідження у вигляді презентації, звіту та відеозапису доповіді.


1.2 Історія змін


Таблиця 1 — Історія змін та виправлень роботи
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	20.04.2025
	0.1
	Створено розділ «Історія змін»
	2
	20.04.2025
	0.1
	Створено розділ «Хід роботи»
	3
	20.04.2025
	0.1
	Додано слайди презентації в додаток Б
	4
	20.04.2025
	0.1
	Додано програмний код у додаток В
	5
	20.04.2025
	0.1
	Створено розділ «Висновки»
	6
	21.04.2025
	0.1
	Додано посилання на відеозапис доповіді в додаток А
	

________________


1.3 Завдання


                У межах практичного заняття №1 студент повинен виконати наступні завдання:
1. Вивчити загальні принципи шаблонів проєктування та ознайомитися з класифікацією патернів.
2. Поглиблено дослідити патерн Strategy: його структуру, призначення, переваги та недоліки.
3. Підготувати усну доповідь тривалістю 10–12 хвилин з демонстрацією прикладу реалізації патерна мовою програмування C++.
4. Створити інформативну презентацію доповіді українською мовою.
5. Записати та опублікувати відеозапис доповіді на платформі YouTube.
6. Оформити письмовий звіт відповідно до вимог ДСТУ 3008:2015, включаючи всі необхідні розділи та додатки.
7. Створити GitHub-репозиторій згідно з технічним завданням і розмістити в ньому презентацію, відеозапис, приклади програмного коду та текстовий звіт.


1.3 Опис роботи


        У межах поставленого завдання було обрано для вивчення шаблон (патерн) проєктування Strategy. Опрацьовано джерела, зокрема книгу «Design Patterns: Elements of Reusable Object-Oriented Software» (GoF), а також сучасні статті й практичні приклади. Було сформульовано зміст доповіді, яка включає 10 змістовних розділів тривалістю до 15 хвилин.
Реалізовано приклад патерна Strategy мовою програмування C++ із демонстрацією інтерфейсу стратегії, конкретних реалізацій і контексту. Створено презентацію у вигляді слайдів із коротким викладом теорії, діаграмою UML та прикладами використання.
Проведено відеозапис доповіді, який опубліковано на YouTube з дотриманням вимог до тривалості, мови та структури. Підготовлено письмовий звіт у форматі PDF і TXT із повним описом виконаних дій, вставками коду, слайдами презентації та хронологічним описом доповіді.
Організовано GitHub-репозиторій з необхідною структурою директорій, де розміщено презентацію, код, звіт і README.md з інформацією згідно з вимогами. Робота повністю відповідає технічному завданню практичного заняття №1 з дисципліни «Патерни проєктування».
1.4 Висновки


        У ході виконання практичного завдання було розглянуто патерн проєктування Strategy як представника поведінкових шаблонів. Опрацювання теоретичних джерел дозволило сформувати цілісне уявлення про призначення, структуру та застосування цього патерна.
Було створено приклад реалізації Strategy мовою C++ та оформлено відповідну презентацію доповіді. Також було записано відеозвіт і структуровано матеріали у GitHub-репозиторії. Отримані знання сприятимуть покращенню якості програмних рішень і розвитку навичок об’єктно орієнтованого проєктування.
ДОДАТОК А
Посилання на відеозапис та хронологічний опис доповіді


Відеозапис доповіді на YouTube: https://youtu.be/foL5gry6W3Q


00:00 Тема роботи
00:11 Вступ, або Що таке патерни проєктування та які вони бувають
01:39 Загальний огляд патерна Strategy
02:48 Навiщо використовувати Strategy?
04:14 Структура патерну Strategy
04:51 Приклад застосування на C++
05:50 Реальні приклади
07:24 Переваги патерну Strategy
08:57 Недоліки патерну Strategy
10:38 Порiвняння з iншими патернами
13:03 Висновки
14:23 «Дякую за увагу!» та джерела
________________
ДОДАТОК Б
Слайди презентації


  

Рисунок 1 — Титульний слайд


  

Рисунок 2 — Вступ з визначенням патерну проєктування
  
Рисунок 3 — Патерн Strategy на загальному


  
Рисунок 4 — Мотивація до використання Strategy


  
Рисунок 5 — Структура патерна Strategy


  
Рисунок 6 — Приклад реалізації на C++
  
Рисунок 7 — Застосування Strategy у реальних проєктах


  
Рисунок 8 — Переваги патерну Strategy
  
Рисунок 9 — Недоліки й обмеження патерну Strategy


  
Рисунок 10 — Порівняння Strategy з іншими патернами
  
Рисунок 11 — Висновки


  
Рисунок 12 — Використані джерела
  

Рисунок 13 — «Дякую за увагу!»
________________
ДОДАТОК В
Програмний код прикладу використання патерну проєктування Strategy на мові C++


  1. #include <iostream>
  2. #include <memory>
  3.
  4. // інтерфейс стратегії
  5. class Strategy {
  6. public:
  7.     virtual int execute(int a, int b) const = 0;
  8.     virtual ~Strategy() = default;
  9. };
 10.
 11. // конкретна стратегія — додавання
 12. class AddStrategy : public Strategy {
 13. public:
 14.     int execute(int a, int b) const override {
 15.         return a + b;
 16.     }
 17. };
 18.
 19. // конкретна стратегія — віднімання
 20. class SubtractStrategy : public Strategy {
 21. public:
 22.     int execute(int a, int b) const override {
 23.         return a - b;
 24.     }
 25. };
 26.
 27. // контекст
 28. class Calculator {
 29. private:
 30.     std::unique_ptr<Strategy> strategy;
 31.
 32. public:
 33.     // конструктор з ініціалізацією стратегії
 34.     Calculator(std::unique_ptr<Strategy> s) : strategy(std::move(s)) {}
 35.
 36.     // заміна стратегії під час виконання
 37.     void setStrategy(std::unique_ptr<Strategy> s) {
 38.         strategy = std::move(s);
 39.     }
 40.
 41.     int calculate(int a, int b) const {
 42.         if (strategy) {
 43.             return strategy->execute(a, b);
 44.         }
 45.         else {
 46.             throw std::runtime_error("Strategy not set.");
 47.         }
 48.     }
 49. };
 50.
 51. int main() {
 52.     // починаємо зі стратегії додавання
 53.     Calculator calc(std::make_unique<AddStrategy>());
 54.     std::cout << "5 + 3 = " << calc.calculate(5, 3) << std::endl;
 55.
 56.     // переходимо до стратегїі віднісмання
 57.     calc.setStrategy(std::make_unique<SubtractStrategy>());
 58.     std::cout << "5 - 3 = " << calc.calculate(5, 3) << std::endl;
 59.
 60.     return 0;
 61. }